# -*- coding: utf-8 -*-
"""GANs_in_Slanted_Land.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/github/luisguiserrano/gans/blob/master/GANs_in_Slanted_Land.ipynb

# Generative Adversarial Networks in Slanted Land

In this notebook, we build a very simple pair of GANs.
- The dataset is a dataset of 4x4 black and white images, where the images we want to generate (the faces) are backwards diagonals (\\)
- The neural networks only have one layer.

Below is the YouTube video corresponding to this notebook.

### Imports
"""

# Commented out IPython magic to ensure Python compatibility.
# Imports

import numpy as np
from numpy import random
from matplotlib import pyplot as plt
# %matplotlib inline

"""### Plotting function"""

# Drawing function

def view_samples(samples, m, n):
    fig, axes = plt.subplots(figsize=(10, 10), nrows=m, ncols=n, sharey=True, sharex=True)
    for ax, img in zip(axes.flatten(), samples):
        ax.xaxis.set_visible(False)
        ax.yaxis.set_visible(False)
        im = ax.imshow(1-img.reshape((2,2)), cmap='Greys_r')
    return fig, axes

"""# Examples of faces

In the video, we've defined the faces as backwards diagonals. Here are some examples.
"""

# # Examples of faces
# faces = [np.array([1,0,0,1]),
#          np.array([0.9,0.1,0.2,0.8]),
#          np.array([0.9,0.2,0.1,0.8]),
#          np.array([0.8,0.1,0.2,0.9]),
#          np.array([0.8,0.2,0.1,0.9])]

# _ = view_samples(faces, 1, 4)


#

import numpy as np
import matplotlib.pyplot as plt

# Example faces
faces = [
    np.array([1, 0, 0, 1, 0.9, 0.1, 0.2, 0.8, 0.9, 0.2, 0.1, 0.8, 0.8, 0.1, 0.2, 0.9]),
    np.array([0.9, 0.1, 0.3, 0.7, 0.7, 0.2, 0.1, 0.8, 0.6, 0.3, 0.2, 0.7, 0.9, 0.1, 0.4, 0.5]),
    np.array([0.8, 0.3, 0.4, 0.7, 0.5, 0.2, 0.3, 0.8, 0.9, 0.1, 0.6, 0.7, 0.7, 0.4, 0.5, 0.9]),
    np.array([0.7, 0.4, 0.5, 0.6, 0.5, 0.3, 0.2, 0.8, 0.8, 0.6, 0.1, 0.9, 0.7, 0.2, 0.3, 0.8])
]

# Reshape each face array into 4x5 grid and plot them
fig, axs = plt.subplots(1, len(faces), figsize=(12, 4))

for i, face in enumerate(faces):
    face_reshaped = face.reshape(4, 4)  # Reshaping to 4x5 grid
    axs[i].imshow(face_reshaped, cmap='gray', interpolation='nearest')
    axs[i].axis('off')
    axs[i].set_title(f'Face {i + 1}')

plt.show()

"""# Examples of noise
The following are randomly generated images, which don't correspond to faces.
"""

# # Examples of noisy images
# noise = [np.random.randn(2,2) for i in range(20)]
# def generate_random_image():
#     return [np.random.random(), np.random.random(), np.random.random(), np.random.random()]
# _ = view_samples(noise, 4,5)
import numpy as np
import matplotlib.pyplot as plt

# Generate 20 noisy images as 2x2 random arrays
noise = [np.random.randn(4, 4) for _ in range(20)]

# Set up the plot
fig, axs = plt.subplots(4, 5, figsize=(12, 10))

# Plot each noise array
for i, ax in enumerate(axs.flat):
    ax.imshow(noise[i], cmap='gray', interpolation='nearest')
    ax.axis('off')
    # ax.set_title(f'Noise {i + 1}')

plt.tight_layout()
plt.show()

"""# Building the neural networks"""

# The sigmoid activation function
def sigmoid(x):
    return np.exp(x)/(1.0+np.exp(x))

"""## The Discriminator

<img src="https://github.com/luisguiserrano/gans/blob/master/discriminator_math.png?raw=1" />
"""

class Discriminator:
    def __init__(self):
        self.weights = np.random.randn(16, 1)  # 16 inputs from the image grid
        self.bias = np.random.randn(1)

    def forward(self, image):
        # Flatten the image and pass through the network
        flattened = image.flatten()
        return sigmoid(np.dot(flattened, self.weights) + self.bias)

    def error_from_image(self, image):
        # For real face image
        prediction = self.forward(image)
        return -np.log(prediction)  # Binary cross-entropy loss

    def error_from_noise(self, z):
        # For generated fake face image
        fake_image = G.forward(z)
        prediction = self.forward(fake_image)
        return -np.log(1 - prediction)  # Binary cross-entropy loss

    def update_from_image(self, face):
        # Update using real data (here you'd compute gradients)
        pass

    def update_from_noise(self, noise):
        # Update using fake data (here you'd compute gradients)
        pass

"""## The Generator
<img src="https://github.com/luisguiserrano/gans/blob/master/generator_math.png?raw=1" />
"""

class Generator():
    def __init__(self):
        self.weights = np.array([np.random.normal() for i in range(4)])
        self.biases = np.array([np.random.normal() for i in range(4)])

    def forward(self, z):
        # Forward pass
        return sigmoid(z * self.weights + self.biases)

    def error(self, z, discriminator):
        x = self.forward(z)
        # We want the prediction to be 0, so the error is -log(1-prediction)
        y = discriminator.forward(x)
        return -np.log(y)

    def derivatives(self, z, discriminator):
        discriminator_weights = discriminator.weights
        discriminator_bias = discriminator.bias
        x = self.forward(z)
        y = discriminator.forward(x)
        factor = -(1-y) * discriminator_weights * x *(1-x)
        derivatives_weights = factor * z
        derivative_bias = factor
        return derivatives_weights, derivative_bias

    def update(self, z, discriminator):
        error_before = self.error(z, discriminator)
        ders = self.derivatives(z, discriminator)
        self.weights -= learning_rate * ders[0]
        self.biases -= learning_rate * ders[1]
        error_after = self.error(z, discriminator)



"""# Training"""



import matplotlib.pyplot as plt
plt.plot(errors_generator)
plt.title("Generator error function")
plt.legend("gen")
plt.show()
plt.plot(errors_discriminator)
plt.legend('disc')
plt.title("Discriminator error function")

"""# Generating images"""

generated_images = []
for i in range(4):
    z = random.random()
    generated_image = G.forward(z)
    generated_images.append(generated_image)
_ = view_samples(generated_images, 1, 4)
for i in generated_images:
    print(i)

"""# Studying the weights and biases of the Generator and Discriminator"""

print("Generator weights", G.weights)
print("Generator biases", G.biases)

print("Discriminator weights", D.weights)
print("Discriminator bias", D.bias)



